# Development Log - 2025-07-05

## What's New

#### Dynamic Child Resolution Framework-Wide
The dynamic child resolution mechanism has been elevated from a Container-specific feature to a core Model capability. This fundamental enhancement allows any Model subclass to use Symbol-based child definitions that resolve to methods returning Class objects. Developers can now implement dynamic behavior patterns across the entire framework, not just in layout containers.

The implementation provides robust error handling with clear distinction between missing methods (NoMethodError) and invalid return types (ArgumentError). This enables sophisticated patterns like state-driven component switching while maintaining type safety and developer experience.

#### Container Default View Implementation
Container classes now automatically display their children without requiring boilerplate view methods. Since containers are fundamentally layout mechanisms designed to organize and present child components, the default behavior of `view = children_views` eliminates repetitive code while maintaining the ability to override for custom implementations.

#### Enhanced Flexbox Layout System
The Container layout system has been significantly expanded with bidirectional flexbox support. Developers can now create both column and row layouts with proportional sizing, providing CSS-like flexbox behavior in terminal interfaces. The system includes comprehensive bounds calculation that correctly propagates dimensions and positions to child components.

#### Interactive Layout Examples
Two new comprehensive examples demonstrate the framework's layout capabilities:
- `container_layout.rb`: An interactive demo showcasing dynamic switching between column and row layouts with real-time bounds visualization
- `container_simple.rb`: A basic demonstration of row layout with visual box rendering

These examples integrate with tty-box for professional terminal UI presentation and serve as practical references for developers building TUI applications.

## What's Fixed

#### Hot Reloading and Dynamic Layout Integration
Resolved a critical issue where dynamically created layout components (Row/Column) weren't receiving proper bounds information from their parent containers. Previously, dynamic layouts would use full screen dimensions instead of allocated flex space, breaking layout calculations during hot reload scenarios. The solution involved implementing Symbol-based child resolution that preserves bounds propagation throughout the component hierarchy.

#### View Rendering Consistency
Fixed children_views joining behavior to eliminate unnecessary newlines between child views. This prevents layout breaking in Container scenarios where child components should be positioned adjacently without automatic line separation. The change maintains flexibility for components that specifically need newline separation while providing sensible defaults for layout containers.

#### Test Organization and Coverage
Reorganized test suites to properly reflect the architectural changes. Dynamic child resolution tests were moved from container_spec to model_spec, aligning test coverage with the new framework-wide availability of the feature. This ensures maintainability and prevents confusion about where functionality is implemented.

## Design Decisions

#### Symbol-Based Dynamic Resolution Architecture
**Context**: The original dynamic child resolution was implemented only in Container, limiting its use to layout scenarios. However, the pattern of dynamically selecting child components based on state is valuable across all Model types.

**Decision**: Move the resolution mechanism to the base Model class with a clean API: `resolve_child(klass_or_symbol, state)`.

**Rationale**: This promotes consistency across the framework and enables sophisticated component composition patterns. The Symbol-to-method resolution pattern provides a clean DSL while maintaining Ruby's dynamic capabilities. Error handling distinguishes between missing methods and type validation, providing clear debugging guidance.

#### Container as Pure Layout Component
**Context**: Container subclasses consistently implemented identical `view` methods that simply called `children_views`, representing boilerplate code with no variation.

**Decision**: Implement `def view = children_views` as the default Container behavior.

**Rationale**: Containers exist to organize and present child components, so displaying children is their natural purpose. This reduces cognitive overhead for developers while maintaining override capability for specialized containers. The decision aligns with the principle that containers should be transparent layout mechanisms.

#### Framework-Wide Symbol Resolution
**Context**: Initially, Symbol-based child definitions were Container-specific, creating inconsistency in the framework's component definition patterns.

**Decision**: Standardize Symbol resolution across all Model classes through the base class implementation.

**Rationale**: Consistency improves developer experience and enables advanced patterns like state-driven component composition throughout the framework. The unified approach reduces learning curve and provides predictable behavior regardless of component type.

#### Bounds-Aware Dynamic Components
**Context**: Dynamic layout switching required maintaining proper parent-child bounds relationships while enabling runtime component type changes.

**Decision**: Ensure all dynamic resolution paths preserve bounds information propagation through the unified `resolve_child` method.

**Rationale**: Terminal UI layout requires precise coordinate and dimension management. Breaking bounds propagation creates visual artifacts and layout inconsistencies. The solution maintains flexbox semantics while enabling dynamic behavior.

## Impact

These changes significantly enhance the framework's flexibility and developer experience. The dynamic child resolution system enables sophisticated component composition patterns previously impossible, while the enhanced Container system provides CSS-like layout capabilities for terminal interfaces.

Developers can now build more maintainable TUI applications with less boilerplate code and greater architectural flexibility. The unified Symbol resolution pattern creates consistency across the framework, reducing learning curve and improving code predictability.

The improvements particularly benefit complex applications requiring dynamic layouts, state-driven component switching, and sophisticated terminal interface designs. Hot reloading reliability ensures smooth development experience even with complex dynamic component hierarchies.

## Files Modified

- `lib/milktea/model.rb` - Added dynamic child resolution framework-wide
- `lib/milktea/container.rb` - Added default view implementation, removed Container-specific resolution
- `spec/milktea/model_spec.rb` - Added comprehensive dynamic resolution tests
- `spec/milktea/container_spec.rb` - Reorganized tests, removed duplicated dynamic tests
- `examples/container_layout.rb` - Interactive layout demo with dynamic switching
- `examples/container_simple.rb` - Basic layout demonstration
- `Gemfile` - Added tty-box dependency for enhanced examples
- `lib/milktea/renderer.rb` - Enhanced cursor management for cleaner terminal experience