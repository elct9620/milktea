# Development Log - 2025-07-05

## What's New

#### Dynamic Child Resolution Framework-Wide
The dynamic child resolution mechanism has been elevated from a Container-specific feature to a core Model capability. This fundamental enhancement allows any Model subclass to use Symbol-based child definitions that resolve to methods returning Class objects. Developers can now implement dynamic behavior patterns across the entire framework, not just in layout containers.

The implementation provides robust error handling with clear distinction between missing methods (NoMethodError) and invalid return types (ArgumentError). This enables sophisticated patterns like state-driven component switching while maintaining type safety and developer experience.

#### Container Default View Implementation
Container classes now automatically display their children without requiring boilerplate view methods. Since containers are fundamentally layout mechanisms designed to organize and present child components, the default behavior of `view = children_views` eliminates repetitive code while maintaining the ability to override for custom implementations.

#### Enhanced Flexbox Layout System
The Container layout system has been significantly expanded with bidirectional flexbox support. Developers can now create both column and row layouts with proportional sizing, providing CSS-like flexbox behavior in terminal interfaces. The system includes comprehensive bounds calculation that correctly propagates dimensions and positions to child components.

#### Interactive Layout Examples
Two new comprehensive examples demonstrate the framework's layout capabilities:
- `container_layout.rb`: An interactive demo showcasing dynamic switching between column and row layouts with real-time bounds visualization
- `container_simple.rb`: A basic demonstration of row layout with visual box rendering

These examples integrate with tty-box for professional terminal UI presentation and serve as practical references for developers building TUI applications.

#### Self-Contained Example Architecture
Examples have been completely refactored to use `bundler/inline` with inline gemfiles, making them truly self-contained. Each example now manages its own specific dependencies without affecting the main project's Gemfile. This architectural change eliminates the need for developers to modify project dependencies just to run examples and ensures examples remain functional regardless of the main project's development dependencies.

#### Enhanced Ruby Compatibility and CI Infrastructure
The project now enforces a minimum Ruby version of 3.2+ to ensure Zeitwerk compatibility and modern Ruby feature availability. The CI matrix has been expanded to test against Ruby 3.2, 3.3, and 3.4, providing comprehensive compatibility assurance across current Ruby versions while maintaining focus on supported versions.

## What's Fixed

#### Hot Reloading and Dynamic Layout Integration
Resolved a critical issue where dynamically created layout components (Row/Column) weren't receiving proper bounds information from their parent containers. Previously, dynamic layouts would use full screen dimensions instead of allocated flex space, breaking layout calculations during hot reload scenarios. The solution involved implementing Symbol-based child resolution that preserves bounds propagation throughout the component hierarchy.

#### View Rendering Consistency
Fixed children_views joining behavior to eliminate unnecessary newlines between child views. This prevents layout breaking in Container scenarios where child components should be positioned adjacently without automatic line separation. The change maintains flexibility for components that specifically need newline separation while providing sensible defaults for layout containers.

#### Test Organization and Coverage
Reorganized test suites to properly reflect the architectural changes. Dynamic child resolution tests were moved from container_spec to model_spec, aligning test coverage with the new framework-wide availability of the feature. This ensures maintainability and prevents confusion about where functionality is implemented.

#### Dependency Management and Development Environment
Resolved dependency bloat by removing unnecessary development dependencies (ruby-lsp, logger, rbs, sorbet-runtime) from the main Gemfile. The ruby-lsp dependency was causing maintenance overhead without providing essential functionality for the framework itself. This cleanup reduces installation size and eliminates potential dependency conflicts for users integrating Milktea into their applications.

#### CI Configuration and RuboCop Integration
Fixed CI failures caused by RuboCop plugin configuration issues. Removed unnecessary RuboCop plugins (rubocop-rubycw, rubocop-on-rbs) that were added to resolve CI failures but weren't actually required for this project. The GitHub Actions now correctly use the project's .rubocop.yml configuration without additional plugin dependencies.

## Design Decisions

#### Symbol-Based Dynamic Resolution Architecture
**Context**: The original dynamic child resolution was implemented only in Container, limiting its use to layout scenarios. However, the pattern of dynamically selecting child components based on state is valuable across all Model types.

**Decision**: Move the resolution mechanism to the base Model class with a clean API: `resolve_child(klass_or_symbol, state)`.

**Rationale**: This promotes consistency across the framework and enables sophisticated component composition patterns. The Symbol-to-method resolution pattern provides a clean DSL while maintaining Ruby's dynamic capabilities. Error handling distinguishes between missing methods and type validation, providing clear debugging guidance.

#### Container as Pure Layout Component
**Context**: Container subclasses consistently implemented identical `view` methods that simply called `children_views`, representing boilerplate code with no variation.

**Decision**: Implement `def view = children_views` as the default Container behavior.

**Rationale**: Containers exist to organize and present child components, so displaying children is their natural purpose. This reduces cognitive overhead for developers while maintaining override capability for specialized containers. The decision aligns with the principle that containers should be transparent layout mechanisms.

#### Framework-Wide Symbol Resolution
**Context**: Initially, Symbol-based child definitions were Container-specific, creating inconsistency in the framework's component definition patterns.

**Decision**: Standardize Symbol resolution across all Model classes through the base class implementation.

**Rationale**: Consistency improves developer experience and enables advanced patterns like state-driven component composition throughout the framework. The unified approach reduces learning curve and provides predictable behavior regardless of component type.

#### Bounds-Aware Dynamic Components
**Context**: Dynamic layout switching required maintaining proper parent-child bounds relationships while enabling runtime component type changes.

**Decision**: Ensure all dynamic resolution paths preserve bounds information propagation through the unified `resolve_child` method.

**Rationale**: Terminal UI layout requires precise coordinate and dimension management. Breaking bounds propagation creates visual artifacts and layout inconsistencies. The solution maintains flexbox semantics while enabling dynamic behavior.

#### Ruby Version Requirements and Zeitwerk Compatibility
**Context**: The framework uses Zeitwerk for autoloading, which has specific Ruby version requirements for optimal functionality and stability.

**Decision**: Bump minimum Ruby version requirement from 3.1.0 to 3.2.0 across all project configurations.

**Rationale**: Ruby 3.2+ provides better Zeitwerk integration, improved performance, and access to modern Ruby features that enhance framework capabilities. This decision ensures developers have access to the most stable and feature-complete Ruby environment while maintaining reasonable compatibility with current Ruby versions.

#### Self-Contained Example Dependencies
**Context**: Examples previously relied on development dependencies in the main Gemfile, creating coupling between framework dependencies and example requirements.

**Decision**: Implement `bundler/inline` with inline gemfiles for all examples, making each example completely self-contained.

**Rationale**: This architectural pattern eliminates dependency pollution in the main project while ensuring examples remain functional and runnable without project setup. It demonstrates best practices for Ruby gem development and provides better developer experience for users exploring framework capabilities.

#### Development Dependency Minimization
**Context**: The main Gemfile contained development tools (ruby-lsp, tty-box, listen) that aren't essential for framework functionality but were needed for specific development workflows.

**Decision**: Remove non-essential development dependencies from the main Gemfile and move them to example-specific inline gemfiles where needed.

**Rationale**: This reduces the installation footprint for users integrating Milktea into their applications and eliminates potential dependency conflicts. Essential testing and code quality tools remain in the main Gemfile, while convenience tools are available where specifically needed.

## Impact

These changes significantly enhance the framework's flexibility and developer experience while establishing a more robust foundation for long-term development. The dynamic child resolution system enables sophisticated component composition patterns previously impossible, while the enhanced Container system provides CSS-like layout capabilities for terminal interfaces.

The self-contained example architecture dramatically improves developer onboarding by eliminating setup friction and dependency conflicts. New users can now explore framework capabilities without modifying their development environment or dealing with complex dependency resolution.

The Ruby 3.2+ requirement ensures developers have access to modern language features and optimal Zeitwerk performance, while the streamlined CI pipeline provides faster feedback and more reliable testing across supported Ruby versions.

Developers can now build more maintainable TUI applications with less boilerplate code, greater architectural flexibility, and confidence in cross-version compatibility. The unified Symbol resolution pattern creates consistency across the framework, reducing learning curve and improving code predictability.

The improvements particularly benefit complex applications requiring dynamic layouts, state-driven component switching, and sophisticated terminal interface designs. Hot reloading reliability ensures smooth development experience even with complex dynamic component hierarchies.

## Files Modified

### Core Framework
- `lib/milktea/model.rb` - Added dynamic child resolution framework-wide
- `lib/milktea/container.rb` - Added default view implementation, removed Container-specific resolution
- `lib/milktea/renderer.rb` - Enhanced cursor management for cleaner terminal experience

### Testing and Quality
- `spec/milktea/model_spec.rb` - Added comprehensive dynamic resolution tests
- `spec/milktea/container_spec.rb` - Reorganized tests, removed duplicated dynamic tests
- `.rubocop.yml` - Updated target Ruby version to 3.2, cleaned up plugin configuration

### Examples and Documentation
- `examples/container_layout.rb` - Interactive layout demo with inline dependencies
- `examples/container_simple.rb` - Basic layout demonstration with inline dependencies
- `examples/hot_reload_demo.rb` - Updated to use inline gemfile with listen dependency
- `CLAUDE.md` - Updated Ruby version requirement documentation

### Project Configuration
- `Gemfile` - Removed development dependencies (ruby-lsp, tty-box, listen)
- `Gemfile.lock` - Updated dependency tree reflecting removed packages
- `milktea.gemspec` - Updated minimum Ruby version to 3.2.0
- `.github/workflows/main.yml` - Updated CI matrix for Ruby 3.2, 3.3, 3.4 testing